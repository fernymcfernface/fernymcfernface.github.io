We now turn to nondeterministic machines. A nondeterministic Turing Machine has a similar structure to that of a DTM with one key difference; instead of a transition function which uniquely determines the next state, position and adjusts the read symbol, there is a \textbf{transition relation}, which gives a choice of state, new tape symbol, and change of direction to go to.

\begin{definition}
    A program in a \textbf{nondeterministic Turing Machine} (NDTM) is a tuple $(\Gamma,Q,\delta)$ such that:
    \begin{itemize}
        \item $\Gamma$ is a finite set of tape symbols, including a subset $\Sigma \subset \Gamma$ of input symbols and a unique blank symbol $b \in \Gamma \setminus \Sigma$;
        \item $Q$ is a finite set of states, including a unique start state $q_0$ and two unique halt states $q_Y$ and $q_N$;
        \item $\delta$ represents a \textbf{transition relation}, where, given an input state $q$ and tape symbol $X$, $\delta(q,X)$ is the set of tuples
        \[
        \{ (q_{k_1},Y_1,D_1), (q_{k_2},y_2,D_2), \dots, (q_{k_n},y_n,D_n) \}
        \]
        where $q_{k_i}$ represents a new state, $Y_i$ represents a number to rewrite on the current tape position, and $D_i$ represents a direction (given by $-1, 0$ or $+1$) to shift the tape head.
    \end{itemize}
\end{definition}

The NDTM makes a random choice of transition function. We refer to a sequence of these choices (that begins with the first transition in the computation) as a \textbf{branch} of the computation. We now provide a formal definition of accepting and rejecting in a nondeterministic TM.

\begin{definition}
    Let $\Sigma$ be the alphabet for a program $M$ in a nondeterministic Turing Machine, and consider an instance $x \in \Sigma^*$. We say that $M$ \textbf{halts, computes $x$} or \textbf{decides $x$} if there exists $T \in \mathbb{N}$ such that for all $t \geq T$, the state, location and contents of all cells of $M$ at step $t$ is equal to that at step $t+1$ in all branches of the computation. Furthermore, we say that:
    \begin{itemize}
        \item $M$ \textbf{accepts} $x$ if there exists some branch of $M$ that halts on $q_Y$;
        \item $M$ \textbf{rejects} $x$ if all branches of $M$ that halt on $q_N$;
        \item The language $L_M$ \textbf{recognized} by $M$ is given by the set \[L_M = \{x \in \Sigma^*:\text{$M$ accepts $x$}.\}\]
    \end{itemize}
\end{definition}

\begin{definition}
    We say that an NDTM program $M$ is a \textbf{decider} if $M$ halts for any instance $x$ in $M$.
\end{definition}

We note that the key distinction between a nondeterministic and deterministic Turing Machine is the presence of a choice of transition. This yields an important question of whether or not NDTMs are inherently more powerful than DTMs. To show that this is not the case, we can visualise the set of all possible computations on an input $x$ as a tree, as given in Figure \ref{fig:NDTree}.

\input{Sections/TikZ documents/NDTree}

An accepting computation on $x$ is a branch of the NDTM with finite height. To find an accepting computation on $x$, we use a \textbf{breadth-first search}. This involves starting at the root node, checking its children, and then checking its grandchildren. This process continues until we find a point at which state $q_Y$ is reached. The formal proof for this is given below.

\newpage

\begin{theorem}\label{thm: NDTM DTM equality}
    Any language can be recognised by a program in a deterministic TM if and only if it can be recognised by a program in a nondeterministic TM.
\end{theorem}
\begin{proof}
    ($\implies$) We can express the transition function of a DTM as the transition relation of an NDTM which contains a single branch.

    ($\impliedby$) We will design a multitape DTM that computes this. Without loss of generality construct an arbitrary ordering in each set of tuples within the transition relation. In the DTM set the first tape to be an input tape, the second to be a tape of ID's, and the third to be a scratch tape. In the beginning, there will be 1 ID (the `root' node of the tree of nondeterministic computation), and as always we begin at the first symbol of the input.

    The transition function is given in the following way:

    \begin{enumerate}
        \item Examine the state and scanned symbol of the current ID. If it halts on state $q_Y$, we are done.
        \item Otherwise, consider the transition relation given for the respective state and tape symbol, for which there will be $k$ possible options. Append $k$ IDs at the end of the ID list.
        \item Bring the tape head back to the current ID, erase it and go to the next tape head.
    \end{enumerate}

    The above acts as a breadth-first search through all possible values of the TM, so if the NDTM program accepts an input, so must the constructed DTM program.
\end{proof}